// riscv multi-cycle controller test vectors
// sarah.harris@unlv.edu
// 28 July 2023
// CPE300L Lab 10

// Testbench checks controller outputs for all supported instructions
// lw, sw
// add, sub, and, or, slt, addi
// beq
// jal

// Op[6:0] Funct3[2:0] Funct7b5 Zero _ ImmSrc[1:0] ALUSrcA[1:0] ALUSrcB[1:0] ResultSrc[1:0] AdrSrc ALUControl[2:0] IRWrite PCWrite RegWrite MemWrite

// Test R-type instructions
// Each instruction takes four cycles to execute
// AdrSrc = 0, ImmSrc = XX
// Other outputs based on Fig Multi-cycle controller FSM

//op[6:0]_funct3[2:0]_funct7b5_Zero_ImmSrc[1:0]_ALUSrcA[1:0]_ALUSrcB[1:0]_ResultSrc[1:0]_AdrSrc_ALUControl[2:0]_IRWrite_PCWrite_RegWrite_MemWrite
// add
0110011_000_0_0__00_00_10_10_0_000_1_1_0_0 // 1: Fetch
0110011_000_0_0__00_01_01_00_0_000_0_0_0_0 // 2: Decode
0110011_000_0_0__00_10_00_00_0_000_0_0_0_0 // 3: ExecuteR
0110011_000_0_0__00_00_00_00_0_000_0_0_1_0 // 4: ALUWB

// sub (only differs in ALUControl during ExecuteR)
0110011_000_1_0__00_00_10_10_0_000_1_1_0_0 // 5: Fetch
0110011_000_1_0__00_01_01_00_0_000_0_0_0_0 // 6: Decode
0110011_000_1_0__00_10_00_00_0_001_0_0_0_0 // 7: ExecuteR
0110011_000_1_0__00_00_00_00_0_000_0_0_1_0 // 8: ALUWB

// or (only differs in ALUControl during ExecuteR)
0110011_110_0_0__00_00_10_10_0_000_1_1_0_0 // 9:  Fetch
0110011_110_0_0__00_01_01_00_0_000_0_0_0_0 // 10: Decode
0110011_110_0_0__00_10_00_00_0_011_0_0_0_0 // 11: ExecuteR
0110011_110_0_0__00_00_00_00_0_000_0_0_1_0 // 12: ALUWB

// and (only differs in ALUControl during ExecuteR)
0110011_111_0_0__00_00_10_10_0_000_1_1_0_0 // 13: Fetch
0110011_111_0_0__00_01_01_00_0_000_0_0_0_0 // 14: Decode
0110011_111_0_0__00_10_00_00_0_010_0_0_0_0 // 15: ExecuteR
0110011_111_0_0__00_00_00_00_0_000_0_0_1_0 // 16: ALUWB

// slt (only differs in ALUControl during ExecuteR)
0110011_010_0_0__00_00_10_10_0_000_1_1_0_0 // 17: Fetch
0110011_010_0_0__00_01_01_00_0_000_0_0_0_0 // 18: Decode
0110011_010_0_0__00_10_00_00_0_101_0_0_0_0 // 19: ExecuteR
0110011_010_0_0__00_00_00_00_0_000_0_0_1_0 // 20: ALUWB

// Test I-type instructions (lw, addi)
// lw takes five cycles to execute, addi takes four cycles
// ImmSrc = 00
// Other outputs based on Fig Multi-cycle controller FSM

//{Op[6:0]}_{Funct3[2:0]}_{Funct7b5}_{Zero}__{ImmSrc[1:0]}_{ALUSrcA[1:0]}_{ALUSrcB[1:0]}_{ResultSrc[1:0]}_{AdrSrc}_{ALUControl[2:0]}_{IRWrite}_{PCWrite}_{RegWrite}_{MemWrite}

// lw
0000011_010_0_0__00_00_10_10_0_000_1_1_0_0 // 21: Fetch
0000011_010_0_0__00_01_01_00_0_000_0_0_0_0 // 22: Decode
0000011_010_0_0__00_10_01_00_0_000_0_0_0_0 // 23: MemAdr
0000011_010_0_0__00_00_00_00_1_000_0_0_0_0 // 24: MemRead
0000011_010_0_0__00_00_00_01_0_000_0_0_1_0 // 25: MemWB

// addi
0010011_000_0_0__00_00_10_10_0_000_1_1_0_0 // 26: Fetch
0010011_000_0_0__00_01_01_00_0_000_0_0_0_0 // 27: Decode
0010011_000_0_0__00_10_01_00_0_000_0_0_0_0 // 28: ExecuteI
0010011_000_0_0__00_00_00_00_0_000_0_0_1_0 // 29: ALUWB

// Test S-type instructions (sw)
// sw takes four cycles to execute
// ImmSrc = 01
// Other outputs based on Fig Multi-cycle controller FSM

//{Op[6:0]}_{Funct3[2:0]}_{Funct7b5}_{Zero}__{ImmSrc[1:0]}_{ALUSrcA[1:0]}_{ALUSrcB[1:0]}_{ResultSrc[1:0]}_{AdrSrc}_{ALUControl[2:0]}_{IRWrite}_{PCWrite}_{RegWrite}_{MemWrite}

// sw
0100011_010_0_0__01_00_10_10_0_000_1_1_0_0 // 30: Fetch
0100011_010_0_0__01_01_01_00_0_000_0_0_0_0 // 31: Decode
0100011_010_0_0__01_10_01_00_0_000_0_0_0_0 // 32: MemAdr
0100011_010_0_0__01_00_00_00_1_000_0_0_0_1 // 33: MemWrite

// Test B-type instructions (beq)
// beq takes three cycles to execute
// ImmSrc = 10
// Other outputs based on Fig Multi-cycle controller FSM

//{Op[6:0]}_{Funct3[2:0]}_{Funct7b5}_{Zero}__{ImmSrc[1:0]}_{ALUSrcA[1:0]}_{ALUSrcB[1:0]}_{ResultSrc[1:0]}_{AdrSrc}_{ALUControl[2:0]}_{IRWrite}_{PCWrite}_{RegWrite}_{MemWrite}

// beq
1100011_000_0_0__10_00_10_10_0_000_1_1_0_0 // 34: Fetch
1100011_000_0_0__10_01_01_00_0_000_0_0_0_0 // 35: Decode
1100011_000_0_0__10_10_00_00_0_001_0_0_0_0 // 36: BEQ

// Test J-type instructions (jal)
// beq takes four cycles to execute
// ImmSrc = 11
// Other outputs based on Fig Multi-cycle controller FSM

//{Op[6:0]}_{Funct3[2:0]}_{Funct7b5}_{Zero}__{ImmSrc[1:0]}_{ALUSrcA[1:0]}_{ALUSrcB[1:0]}_{ResultSrc[1:0]}_{AdrSrc}_{ALUControl[2:0]}_{IRWrite}_{PCWrite}_{RegWrite}_{MemWrite}

1101111_000_0_0__11_00_10_10_0_000_1_1_0_0 // 37: Fetch
1101111_000_0_0__11_01_01_00_0_000_0_0_0_0 // 38: Decode
1101111_000_0_0__11_01_10_00_0_000_0_1_0_0 // 39: JAL
1101111_000_0_0__11_00_00_00_0_000_0_0_1_0 // 40: ALUWB